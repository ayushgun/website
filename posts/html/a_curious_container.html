<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: #d8dee9;
        background-color: #242933;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: #d8dee9;
        background-color: #242933;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #242933;
        background-color: #d8dee9;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #242933;
        background-color: #d8dee9;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #3b4252;
      }
      .codehilite {
        background: #2e3440;
        color: #d8dee9;
      }
      .codehilite .c {
        color: #616e87;
        font-style: italic;
      } /* Comment */
      .codehilite .err {
        color: #bf616a;
      } /* Error */
      .codehilite .esc {
        color: #d8dee9;
      } /* Escape */
      .codehilite .g {
        color: #d8dee9;
      } /* Generic */
      .codehilite .k {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword */
      .codehilite .l {
        color: #d8dee9;
      } /* Literal */
      .codehilite .n {
        color: #d8dee9;
      } /* Name */
      .codehilite .o {
        color: #81a1c1;
        font-weight: normal;
      } /* Operator */
      .codehilite .x {
        color: #d8dee9;
      } /* Other */
      .codehilite .p {
        color: #eceff4;
      } /* Punctuation */
      .codehilite .ch {
        color: #616e87;
        font-style: italic;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #616e87;
        font-style: italic;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #5e81ac;
        font-style: italic;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #616e87;
        font-style: italic;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #616e87;
        font-style: italic;
      } /* Comment.Single */
      .codehilite .cs {
        color: #616e87;
        font-style: italic;
      } /* Comment.Special */
      .codehilite .gd {
        color: #bf616a;
      } /* Generic.Deleted */
      .codehilite .ge {
        color: #d8dee9;
        font-style: italic;
      } /* Generic.Emph */
      .codehilite .ges {
        color: #d8dee9;
        font-weight: normal;
        font-style: italic;
      } /* Generic.EmphStrong */
      .codehilite .gr {
        color: #bf616a;
      } /* Generic.Error */
      .codehilite .gh {
        color: #88c0d0;
        font-weight: normal;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #a3be8c;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #d8dee9;
      } /* Generic.Output */
      .codehilite .gp {
        color: #616e88;
        font-weight: normal;
      } /* Generic.Prompt */
      .codehilite .gs {
        color: #d8dee9;
        font-weight: normal;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #88c0d0;
        font-weight: normal;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #bf616a;
      } /* Generic.Traceback */
      .codehilite .kc {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #81a1c1;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #81a1c1;
      } /* Keyword.Type */
      .codehilite .ld {
        color: #d8dee9;
      } /* Literal.Date */
      .codehilite .m {
        color: #b48ead;
      } /* Literal.Number */
      .codehilite .s {
        color: #a3be8c;
      } /* Literal.String */
      .codehilite .na {
        color: #8fbcbb;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #81a1c1;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #8fbcbb;
      } /* Name.Class */
      .codehilite .no {
        color: #8fbcbb;
      } /* Name.Constant */
      .codehilite .nd {
        color: #d08770;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #d08770;
      } /* Name.Entity */
      .codehilite .ne {
        color: #bf616a;
      } /* Name.Exception */
      .codehilite .nf {
        color: #88c0d0;
      } /* Name.Function */
      .codehilite .nl {
        color: #d8dee9;
      } /* Name.Label */
      .codehilite .nn {
        color: #8fbcbb;
      } /* Name.Namespace */
      .codehilite .nx {
        color: #d8dee9;
      } /* Name.Other */
      .codehilite .py {
        color: #d8dee9;
      } /* Name.Property */
      .codehilite .nt {
        color: #81a1c1;
      } /* Name.Tag */
      .codehilite .nv {
        color: #d8dee9;
      } /* Name.Variable */
      .codehilite .ow {
        color: #81a1c1;
        font-weight: normal;
      } /* Operator.Word */
      .codehilite .pm {
        color: #eceff4;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #d8dee9;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #b48ead;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #b48ead;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #b48ead;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #b48ead;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #b48ead;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #a3be8c;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #a3be8c;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #a3be8c;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #a3be8c;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #616e87;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #a3be8c;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #ebcb8b;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #a3be8c;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #a3be8c;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #a3be8c;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #ebcb8b;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #a3be8c;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #a3be8c;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #81a1c1;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #88c0d0;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #d8dee9;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #d8dee9;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #d8dee9;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #d8dee9;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #b48ead;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>A Curious Container</h1>
        <blockquote>
          <p>May 20, 2023</p>
        </blockquote>
        <p>
          <code>std::tuple</code>, introduced in C++11, is one of the most
          interesting containers available in the standard library.
        </p>
        <p>
          Why? <code>std::tuple</code> defies traditional STL container
          characteristics with its unique features like being type-flexible,
          stack-allocated, and having a distinct interface.
        </p>
        <h2>What exactly is <code>std::tuple</code>?</h2>
        <p>
          Formally, <code>std::tuple</code> is a templated class that
          encapsulates a fixed-size collection of heterogeneous values, each
          potentially of a different type. It shines in scenarios requiring
          multiple return values from a function or in complex data operations
          involving varied types.
        </p>
        <p>
          Contrasting with contiguous containers like
          <code>std::vector</code> or <code>std::array</code>,
          <code>std::tuple</code> lacks a subscript operator for index-based
          access. Instead, its type-flexible nature demands element access via
          <code>std::get&lt;I&gt;</code>, which uses a template argument to
          specify the element's index.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4.5</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"> </span><span class="c1">// prints 1 to stdout</span>
<span class="p">}</span>
</code></pre>
        </div>

        <h2>A Closer Examination</h2>
        <p>So why is <code>std::tuple</code> so unique as a container?</p>
        <p>
          <code>std::tuple</code> stands out due to its extensive use of
          template metaprogramming, which in this case, improves type safety and
          enables stack allocation. Functions like
          <code>std::get&lt;I&gt;</code> utilize compile-time type and index
          deduction. Recursive template instantiation and specialization
          facilitate safe and unique operations on the tuple's elements.
        </p>
        <p>
          Internally, <code>std::tuple</code> can be analogized to a struct.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>

<span class="c1">// is roughly equivalent to...</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Tuple</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">element_1</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">element_2</span><span class="p">{</span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>
<span class="p">};</span>
</code></pre>
        </div>

        <h2>Looking Under The Hood</h2>
        <p>
          Let's examine a simplified <code>std::tuple</code> implementation.
        </p>
        <p>
          We start with foundational templates, which are crucial for type
          manipulations and sequence generation.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Type</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Identifier</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Type</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Type</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">TypeOf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Type</span><span class="o">::</span><span class="n">type</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span><span class="w"> </span><span class="n">Indices</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">IndexSequence</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Identifier</span><span class="o">&lt;</span><span class="n">IndexSequence</span><span class="o">&lt;</span><span class="n">Indices</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{};</span>
</code></pre>
        </div>

        <p>
          The <code>ElementSelector</code> template selects the N-th element
          from a type list, while <code>SequenceGenerator</code> creates
          numerical sequences, essential for indexing and accessing tuple
          elements.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="c1">// Select the N-th element in list &lt;Types...&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Types</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ElementSelector</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Head</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Tail</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ElementSelector</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">Head</span><span class="p">,</span><span class="w"> </span><span class="n">Tail</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ElementSelector</span><span class="o">&lt;</span><span class="n">Index</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">Tail</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Head</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Tail</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ElementSelector</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Head</span><span class="p">,</span><span class="w"> </span><span class="n">Tail</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Identifier</span><span class="o">&lt;</span><span class="n">Head</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Types</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">SelectElement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeOf</span><span class="o">&lt;</span><span class="n">ElementSelector</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">Types</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// Generate sequence &lt;0, ..., Length - 1&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Length</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Sequence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IndexSequence</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SequenceGenerator</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Length</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">Current</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">...</span><span class="w"> </span><span class="n">Numbers</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SequenceGenerator</span><span class="o">&lt;</span><span class="n">Length</span><span class="p">,</span><span class="w"> </span><span class="n">Current</span><span class="p">,</span><span class="w"> </span><span class="n">IndexSequence</span><span class="o">&lt;</span><span class="n">Numbers</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SequenceGenerator</span><span class="o">&lt;</span><span class="n">Length</span><span class="p">,</span><span class="w"> </span><span class="n">Current</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">IndexSequence</span><span class="o">&lt;</span><span class="n">Numbers</span><span class="p">...,</span><span class="w"> </span><span class="n">Current</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Length</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">...</span><span class="w"> </span><span class="n">Numbers</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SequenceGenerator</span><span class="o">&lt;</span><span class="n">Length</span><span class="p">,</span><span class="w"> </span><span class="n">Length</span><span class="p">,</span><span class="w"> </span><span class="n">IndexSequence</span><span class="o">&lt;</span><span class="n">Numbers</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IndexSequence</span><span class="o">&lt;</span><span class="n">Numbers</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Length</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">GenerateSequence</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeOf</span><span class="o">&lt;</span><span class="n">SequenceGenerator</span><span class="o">&lt;</span><span class="n">Length</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</code></pre>
        </div>

        <p>
          The <code>TupleElement</code> class template encapsulates each tuple
          element with its index, allowing direct access.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="c1">// Represents an individual tuple element</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">Element</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TupleElement</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Element</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Element</span><span class="o">&amp;</span><span class="w"> </span><span class="n">getValue</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Element</span><span class="o">&amp;</span><span class="w"> </span><span class="n">getValue</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
        </div>

        <p>
          The <code>TupleImplementation</code> class template uses multiple
          inheritance and variadic templates to compose the tuple, with elements
          uniquely accessible via their index.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Indices</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Elements</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TupleImplementation</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span><span class="w"> </span><span class="n">Indices</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Elements</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TupleImplementation</span><span class="o">&lt;</span><span class="n">IndexSequence</span><span class="o">&lt;</span><span class="n">Indices</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Elements</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">TupleElement</span><span class="o">&lt;</span><span class="n">Indices</span><span class="p">,</span><span class="w"> </span><span class="n">Elements</span><span class="o">&gt;</span><span class="p">...</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Index</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">PickElement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SelectElement</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">Elements</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Index</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">Element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TupleElement</span><span class="o">&lt;</span><span class="n">Index</span><span class="p">,</span><span class="w"> </span><span class="n">PickElement</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Index</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">PickElement</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">getElement</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Element</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;::</span><span class="n">getValue</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">Index</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">PickElement</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">getElement</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Element</span><span class="o">&lt;</span><span class="n">Index</span><span class="o">&gt;::</span><span class="n">getValue</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Elements</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Tuple</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">TupleImplementation</span><span class="o">&lt;</span><span class="n">GenerateSequence</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Elements</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Elements</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Elements</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
        </div>

        <p>
          This implementation encapsulates each element in its unique type,
          ensuring type safety and efficiency, elegantly bypassing the need for
          complex specializations.
        </p>
        <h2>Resources</h2>
        <p>
          If you'd like to learn more about <code>std::tuple</code>, here are
          some resources I found informative:
        </p>
        <ul>
          <li>
            <a href="https://en.cppreference.com/w/cpp/utility/tuple"
              >https://en.cppreference.com/w/cpp/utility/tuple</a
            >
          </li>
          <li>
            <a href="https://en.cppreference.com/w/cpp/utility/tuple/get"
              >https://en.cppreference.com/w/cpp/utility/tuple/get</a
            >
          </li>
          <li>
            <a href="https://codereview.stackexchange.com/a/44832"
              >https://codereview.stackexchange.com/a/44832</a
            >
          </li>
        </ul>
      </div>
    </div>
  </body>
</html>
