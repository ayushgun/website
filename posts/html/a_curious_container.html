<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: inherit;
        background-color: transparent;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: inherit;
        background-color: transparent;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #000000;
        background-color: #ffffc0;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #000000;
        background-color: #ffffc0;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #ffffcc;
      }
      .codehilite {
        background: #ffffff;
      }
      .codehilite .c {
        color: #888888;
        font-style: normal;
      } /* Comment */
      .codehilite .err {
        background-color: #a848a8;
      } /* Error */
      .codehilite .k {
        color: #2838b0;
      } /* Keyword */
      .codehilite .o {
        color: #666666;
      } /* Operator */
      .codehilite .p {
        color: #888888;
      } /* Punctuation */
      .codehilite .ch {
        color: #287088;
        font-style: normal;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #888888;
        font-style: normal;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #289870;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #888888;
        font-style: normal;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #888888;
        font-style: normal;
      } /* Comment.Single */
      .codehilite .cs {
        color: #888888;
        font-style: normal;
      } /* Comment.Special */
      .codehilite .gd {
        color: #c02828;
      } /* Generic.Deleted */
      .codehilite .ge {
        font-style: normal;
      } /* Generic.Emph */
      .codehilite .ges {
        font-weight: normal;
        font-style: normal;
      } /* Generic.EmphStrong */
      .codehilite .gr {
        color: #c02828;
      } /* Generic.Error */
      .codehilite .gh {
        color: #666666;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #388038;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #666666;
      } /* Generic.Output */
      .codehilite .gp {
        color: #444444;
      } /* Generic.Prompt */
      .codehilite .gs {
        font-weight: normal;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #444444;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #2838b0;
      } /* Generic.Traceback */
      .codehilite .kc {
        color: #444444;
        font-style: normal;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #2838b0;
        font-style: normal;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #2838b0;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #2838b0;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #2838b0;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #2838b0;
        font-style: normal;
      } /* Keyword.Type */
      .codehilite .m {
        color: #444444;
      } /* Literal.Number */
      .codehilite .s {
        color: #b83838;
      } /* Literal.String */
      .codehilite .na {
        color: #388038;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #388038;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #287088;
      } /* Name.Class */
      .codehilite .no {
        color: #b85820;
      } /* Name.Constant */
      .codehilite .nd {
        color: #287088;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #709030;
      } /* Name.Entity */
      .codehilite .ne {
        color: #908828;
      } /* Name.Exception */
      .codehilite .nf {
        color: #785840;
      } /* Name.Function */
      .codehilite .nl {
        color: #289870;
      } /* Name.Label */
      .codehilite .nn {
        color: #289870;
      } /* Name.Namespace */
      .codehilite .nt {
        color: #2838b0;
      } /* Name.Tag */
      .codehilite .nv {
        color: #b04040;
      } /* Name.Variable */
      .codehilite .ow {
        color: #a848a8;
      } /* Operator.Word */
      .codehilite .pm {
        color: #888888;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #a89028;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #444444;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #444444;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #444444;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #444444;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #444444;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #444444;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #b83838;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #a848a8;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #b85820;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #b85820;
        font-style: normal;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #b83838;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #709030;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #b83838;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #b83838;
        text-decoration: underline;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #a848a8;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #a848a8;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #b83838;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #b83838;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #388038;
        font-style: normal;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #b85820;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #b04040;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #908828;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #b04040;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #b85820;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #444444;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
    <title>Ayush Gundawar &mdash; Post</title>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>A Curious Container</h1>
        <blockquote>
          <p>May 20, 2023</p>
        </blockquote>
        <p>
          <code>std::tuple</code>, introduced in C++11, is a distinctive
          container in the standard library. Unlike traditional STL containers,
          it is type-flexible, stack-allocated, and has a notably unique
          interface.
        </p>
        <h2>Tuple Overview</h2>
        <p>
          Formally, <code>std::tuple</code> is a templated class that
          encapsulates a fixed-size collection of heterogeneous values, each
          potentially of a different type [0]. It is particularly useful for
          generic operations, such as returning multiple values from a function
          or storing function arguments for delayed execution.
        </p>
        <p>
          Contrasting with contiguous containers like
          <code>std::vector</code> or <code>std::array</code>,
          <code>std::tuple</code> lacks a subscript operator for index-based
          access. Instead, it overloads <code>std::get</code> to expose tuple
          elements by requiring the caller to provide an element's index via a
          template argument [0].
        </p>
        <p>For example, to access the first element in a tuple:</p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4.25</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre>
        </div>

        <h2>Closer Examination</h2>
        <p>So why is <code>std::tuple</code> so unique as a container?</p>
        <p>
          <code>std::tuple</code> stands out due to its extensive use of
          template metaprogramming to store heterogeneous types. Informally,
          <code>std::tuple</code> can be analogized to a struct:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>

<span class="c1">// is roughly equal to:</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">tuple</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">value_1</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">value_2</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">};</span>
</code></pre>
        </div>

        <h2>Looking Under The Hood</h2>
        <p>
          Let's examine a C++ tuple implementation. For simplicity's sake, this
          implementation will only hold unique types (i.e., two objects of the
          same type are not allowed) and will not consider move semantics.
        </p>
        <p>
          We begin with a minimal wrapper around an object of type
          <code>T</code>:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">leaf</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
        </div>

        <p>
          We then implement our core template class, which inherits from a
          <code>leaf&lt;T&gt;</code> for every <code>T</code> in a variadic
          template argument pack <code>Ts</code>:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">unique_tuple</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">leaf</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">...</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">unique_tuple</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Ts</span><span class="o">&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">leaf</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">)...</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>
</code></pre>
        </div>

        <p>
          From this, we can implement a <code>std::get</code>-esque
          <code>get</code> template function which returns the object held in
          the tuple for a specified type <code>T</code>:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="c1">// Const overload:</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">unique_tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">tuple</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">leaf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">).</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Non-const overload:</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">unique_tuple</span><span class="o">&lt;</span><span class="n">Ts</span><span class="p">...</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">tuple</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">leaf</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&gt;</span><span class="p">(</span><span class="n">tuple</span><span class="p">).</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          The punchline is that, since <code>unique_tuple</code> inherits from a
          <code>leaf&lt;T&gt;</code> for all <code>T</code> in <code>Ts</code>,
          we are allowed to cast a <code>unique_tuple</code> object into a
          respective <code>leaf&lt;T&gt;</code> object for a specified type
          <code>T</code>. We can then access the object stored in that
          <code>leaf&lt;T&gt;</code> via its public <code>value</code> member.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">unique_tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre>
        </div>

        <h2>Resources</h2>
        <p>
          [0]
          <a href="https://en.cppreference.com/w/cpp/utility/tuple"
            >https://en.cppreference.com/w/cpp/utility/tuple</a
          >
        </p>
        <p>
          [1]
          <a href="https://codereview.stackexchange.com/a/44832"
            >https://codereview.stackexchange.com/a/44832</a
          >
        </p>
      </div>
    </div>
  </body>
</html>
