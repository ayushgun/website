<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: inherit;
        background-color: transparent;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: inherit;
        background-color: transparent;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #000000;
        background-color: #ffffc0;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #000000;
        background-color: #ffffc0;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #ffffcc;
      }
      .codehilite {
        background: #282c34;
        color: #abb2bf;
      }
      .codehilite .c {
        color: #7f848e;
      } /* Comment */
      .codehilite .err {
        color: #abb2bf;
      } /* Error */
      .codehilite .esc {
        color: #abb2bf;
      } /* Escape */
      .codehilite .g {
        color: #abb2bf;
      } /* Generic */
      .codehilite .k {
        color: #c678dd;
      } /* Keyword */
      .codehilite .l {
        color: #abb2bf;
      } /* Literal */
      .codehilite .n {
        color: #e06c75;
      } /* Name */
      .codehilite .o {
        color: #56b6c2;
      } /* Operator */
      .codehilite .x {
        color: #abb2bf;
      } /* Other */
      .codehilite .p {
        color: #abb2bf;
      } /* Punctuation */
      .codehilite .ch {
        color: #7f848e;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #7f848e;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #7f848e;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #7f848e;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #7f848e;
      } /* Comment.Single */
      .codehilite .cs {
        color: #7f848e;
      } /* Comment.Special */
      .codehilite .gd {
        color: #abb2bf;
      } /* Generic.Deleted */
      .codehilite .ge {
        color: #abb2bf;
      } /* Generic.Emph */
      .codehilite .gr {
        color: #abb2bf;
      } /* Generic.Error */
      .codehilite .gh {
        color: #abb2bf;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #abb2bf;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #abb2bf;
      } /* Generic.Output */
      .codehilite .gp {
        color: #abb2bf;
      } /* Generic.Prompt */
      .codehilite .gs {
        color: #abb2bf;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #abb2bf;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #abb2bf;
      } /* Generic.Traceback */
      .codehilite .kc {
        color: #e5c07b;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #c678dd;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #c678dd;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #c678dd;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #c678dd;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #e5c07b;
      } /* Keyword.Type */
      .codehilite .ld {
        color: #abb2bf;
      } /* Literal.Date */
      .codehilite .m {
        color: #d19a66;
      } /* Literal.Number */
      .codehilite .s {
        color: #98c379;
      } /* Literal.String */
      .codehilite .na {
        color: #e06c75;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #e5c07b;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #e5c07b;
      } /* Name.Class */
      .codehilite .no {
        color: #e06c75;
      } /* Name.Constant */
      .codehilite .nd {
        color: #61afef;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #e06c75;
      } /* Name.Entity */
      .codehilite .ne {
        color: #e06c75;
      } /* Name.Exception */
      .codehilite .nf {
        color: #61afef;
        font-weight: normal;
      } /* Name.Function */
      .codehilite .nl {
        color: #e06c75;
      } /* Name.Label */
      .codehilite .nn {
        color: #e06c75;
      } /* Name.Namespace */
      .codehilite .nx {
        color: #e06c75;
      } /* Name.Other */
      .codehilite .py {
        color: #e06c75;
      } /* Name.Property */
      .codehilite .nt {
        color: #e06c75;
      } /* Name.Tag */
      .codehilite .nv {
        color: #e06c75;
      } /* Name.Variable */
      .codehilite .ow {
        color: #56b6c2;
      } /* Operator.Word */
      .codehilite .pm {
        color: #abb2bf;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #abb2bf;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #d19a66;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #d19a66;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #d19a66;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #d19a66;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #d19a66;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #98c379;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #98c379;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #98c379;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #98c379;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #98c379;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #98c379;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #98c379;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #98c379;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #98c379;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #98c379;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #98c379;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #98c379;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #98c379;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #e5c07b;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #56b6c2;
        font-weight: normal;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #e06c75;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #e06c75;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #e06c75;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #e06c75;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #d19a66;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>A Curious Container</h1>
        <blockquote>
          <p>May 20, 2023</p>
        </blockquote>
        <p>
          <code>std::tuple</code>, introduced in C++11, is one of the most
          interesting containers available in the STL.
        </p>
        <p>
          Why? It doesn't adhere to the conventional traits of STL containers.
          It's a curious mix of being type agnostic, stack allocated, and
          distinctively different in its interface.
        </p>
        <h2>What exactly is <code>std::tuple</code>?</h2>
        <p>
          Formally, <code>std::tuple</code> is a template class with an ability
          to encapsulate a collection of heterogeneous values, each potentially
          of a different type, fixed in size. It's particularly invaluable when
          there's a need to return multiple values from a function, or when
          dealing with complex data manipulations involving mixed types.
        </p>
        <p>
          Unlike other contiguous containers, like <code>std::vector</code> or
          <code>std::array</code>, <code>std::tuple</code> doesn't define a
          subscript operator for accessing elements by index. Instead, because
          of its type agnostic nature, elements in a <code>std::tuple</code> are
          individually accessible using the
          <code>std::get&lt;I&gt;</code> function, which takes the index of the
          desired element as a template argument.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4.5</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
        </div>

        <h2>A Closer Examination</h2>
        <p>
          So why is <code>std::tuple</code> so unique as a container? It's the
          byproduct of extensive template-meta programming, especially in
          regards to its type safety.
        </p>
        <p>
          Template metaprogramming allows <code>std::tuple</code> to generate
          code that is tailored to handle these specific types, allowing for
          type safety and stack allocation. Functions like
          <code>std::get&lt;I&gt;</code>, which retrieve elements from a tuple,
          rely on template arguments to deduce the type and index of the element
          at compile time. Recursive template instantiations and specializations
          are often employed to navigate through the tuple's elements, making
          operations like accessing, modifying, and iterating over elements both
          type-safe, yet uniquely implemented.
        </p>
        <p>
          Fundamentally, under the hood, <code>std::tuple</code> can be thought
          of being directly translated to a struct.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>

<span class="c1">// is roughly equivalent to...</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Tuple</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">element_1</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">element_2</span><span class="p">{</span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>
<span class="p">};</span>
</code></pre>
        </div>

        <h2>Looking Under The Hood</h2>
        <p>
          To unravel the nuances and intricacies of <code>std::tuple</code>,
          let's delve deeper into a refined version of its implementation. This
          refined version has been written to be readable and comprehensible,
          thanks to auxiliary template structures and variadic templates.
        </p>
        <p>
          We initiate our journey with helper templates. These helpers, though
          succinct, play a pivotal role in unraveling the complexity of
          <code>std::tuple</code>. Take, for instance, the <code>id</code> and
          <code>type_of</code> templates, instrumental for type manipulations,
          or the <code>sizes</code> template, used for generating sequences of
          numbers.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="c1">// helpers</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">id</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"> </span><span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">type_of</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">type</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sizes</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">id</span><span class="o">&lt;</span><span class="n">sizes</span><span class="o">&lt;</span><span class="n">N</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{};</span>
</code></pre>
        </div>

        <p>
          The <code>Choose</code> template enables the selection of the N-th
          element from a type list, while <code>Range</code> generates a
          sequence of numbers, a mechanism pivotal for indexing and accessing
          elements within our tuple.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="c1">// choose N-th element in list &lt;T...&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Choose</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">H</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Choose</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Choose</span><span class="o">&lt;</span><span class="n">N</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">H</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Choose</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">id</span><span class="o">&lt;</span><span class="n">H</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">choose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type_of</span><span class="o">&lt;</span><span class="n">Choose</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c1">// given L&gt;=0, generate sequence &lt;0, ..., L-1&gt;</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sizes</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Range</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">...</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Range</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">sizes</span><span class="o">&lt;</span><span class="n">N</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Range</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">sizes</span><span class="o">&lt;</span><span class="n">N</span><span class="p">...,</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">...</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Range</span><span class="o">&lt;</span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="w"> </span><span class="n">sizes</span><span class="o">&lt;</span><span class="n">N</span><span class="p">...</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">sizes</span><span class="o">&lt;</span><span class="n">N</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">L</span><span class="o">&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="n">range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type_of</span><span class="o">&lt;</span><span class="n">Range</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</code></pre>
        </div>

        <p>
          With the foundational templates at our disposal, constructing the
          tuple becomes elegant and efficient. The <code>TupleElem</code> class
          template ensures each element is encapsulated with its index, enabling
          direct access.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="c1">// single tuple element</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TupleElem</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">elem</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">elem</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">elem</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
        </div>

        <p>
          The <code>TupleImpl</code> class template leverages multiple
          inheritance and variadic templates to encapsulate each element within
          the tuple, each uniquely accessible through its index, thanks to the
          <code>get</code> method.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="c1">// tuple implementation</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">N</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TupleImpl</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">...</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TupleImpl</span><span class="o">&lt;</span><span class="n">sizes</span><span class="o">&lt;</span><span class="n">N</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">TupleElem</span><span class="o">&lt;</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">...</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">pick</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">choose</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">elem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TupleElem</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">pick</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">pick</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">elem</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="kt">size_t</span><span class="w"> </span><span class="n">M</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">pick</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">elem</span><span class="o">&lt;</span><span class="n">M</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Tuple</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">TupleImpl</span><span class="o">&lt;</span><span class="n">range</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">...</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="nf">size</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">sizeof</span><span class="p">...(</span><span class="n">T</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
        </div>

        <p>
          In essence, each element, encapsulated within its unique type, becomes
          directly accessible, ensuring type safety and efficiency. The
          implementation is elegant, forgoing the need for intricate
          specializations or static assertions.
        </p>
        <h2>Resources</h2>
        <p>
          If you'd like to dive deeper, here are some resources I found
          interesting:
        </p>
        <ul>
          <li>
            <a href="https://en.cppreference.com/w/cpp/utility/tuple"
              >https://en.cppreference.com/w/cpp/utility/tuple</a
            >
          </li>
          <li>
            <a href="https://en.cppreference.com/w/cpp/utility/tuple/get"
              >https://en.cppreference.com/w/cpp/utility/tuple/get</a
            >
          </li>
          <li>
            <a href="https://codereview.stackexchange.com/a/44832"
              >https://codereview.stackexchange.com/a/44832</a
            >
          </li>
        </ul>
      </div>
    </div>
  </body>
</html>
