<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: #6e7681;
        background-color: #0d1117;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: #6e7681;
        background-color: #0d1117;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #e6edf3;
        background-color: #6e7681;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #e6edf3;
        background-color: #6e7681;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #6e7681;
      }
      .codehilite {
        background: #0d1117;
        color: #e6edf3;
      }
      .codehilite .c {
        color: #8b949e;
        font-style: italic;
      } /* Comment */
      .codehilite .err {
        color: #f85149;
      } /* Error */
      .codehilite .esc {
        color: #e6edf3;
      } /* Escape */
      .codehilite .g {
        color: #e6edf3;
      } /* Generic */
      .codehilite .k {
        color: #ff7b72;
      } /* Keyword */
      .codehilite .l {
        color: #a5d6ff;
      } /* Literal */
      .codehilite .n {
        color: #e6edf3;
      } /* Name */
      .codehilite .o {
        color: #ff7b72;
        font-weight: normal;
      } /* Operator */
      .codehilite .x {
        color: #e6edf3;
      } /* Other */
      .codehilite .p {
        color: #e6edf3;
      } /* Punctuation */
      .codehilite .ch {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #8b949e;
        font-weight: normal;
        font-style: italic;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #8b949e;
        font-style: italic;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Single */
      .codehilite .cs {
        color: #8b949e;
        font-weight: normal;
        font-style: italic;
      } /* Comment.Special */
      .codehilite .gd {
        color: #ffa198;
        background-color: #490202;
      } /* Generic.Deleted */
      .codehilite .ge {
        color: #e6edf3;
        font-style: italic;
      } /* Generic.Emph */
      .codehilite .gr {
        color: #ffa198;
      } /* Generic.Error */
      .codehilite .gh {
        color: #79c0ff;
        font-weight: normal;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #56d364;
        background-color: #0f5323;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #8b949e;
      } /* Generic.Output */
      .codehilite .gp {
        color: #8b949e;
      } /* Generic.Prompt */
      .codehilite .gs {
        color: #e6edf3;
        font-weight: normal;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #79c0ff;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #ff7b72;
      } /* Generic.Traceback */
      .codehilite .g-Underline {
        color: #e6edf3;
        text-decoration: underline;
      } /* Generic.Underline */
      .codehilite .kc {
        color: #79c0ff;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #ff7b72;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #ff7b72;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #79c0ff;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #ff7b72;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #ff7b72;
      } /* Keyword.Type */
      .codehilite .ld {
        color: #79c0ff;
      } /* Literal.Date */
      .codehilite .m {
        color: #a5d6ff;
      } /* Literal.Number */
      .codehilite .s {
        color: #a5d6ff;
      } /* Literal.String */
      .codehilite .na {
        color: #e6edf3;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #e6edf3;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #f0883e;
        font-weight: normal;
      } /* Name.Class */
      .codehilite .no {
        color: #79c0ff;
        font-weight: normal;
      } /* Name.Constant */
      .codehilite .nd {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #ffa657;
      } /* Name.Entity */
      .codehilite .ne {
        color: #f0883e;
        font-weight: normal;
      } /* Name.Exception */
      .codehilite .nf {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Function */
      .codehilite .nl {
        color: #79c0ff;
        font-weight: normal;
      } /* Name.Label */
      .codehilite .nn {
        color: #ff7b72;
      } /* Name.Namespace */
      .codehilite .nx {
        color: #e6edf3;
      } /* Name.Other */
      .codehilite .py {
        color: #79c0ff;
      } /* Name.Property */
      .codehilite .nt {
        color: #7ee787;
      } /* Name.Tag */
      .codehilite .nv {
        color: #79c0ff;
      } /* Name.Variable */
      .codehilite .ow {
        color: #ff7b72;
        font-weight: normal;
      } /* Operator.Word */
      .codehilite .pm {
        color: #e6edf3;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #6e7681;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #a5d6ff;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #a5d6ff;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #a5d6ff;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #a5d6ff;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #a5d6ff;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #79c0ff;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #a5d6ff;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #a5d6ff;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #79c0ff;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #a5d6ff;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #a5d6ff;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #79c0ff;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #79c0ff;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #a5d6ff;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #a5d6ff;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #79c0ff;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #a5d6ff;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #a5d6ff;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #e6edf3;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #79c0ff;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #79c0ff;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #79c0ff;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #79c0ff;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #a5d6ff;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>Third Party Hash Table Implementations in C++</h1>
        <blockquote>
          <p>August 17, 2023</p>
        </blockquote>
        <p>
          HashMaps, or hash tables, are key-value data structures that allow
          efficient insertion, deletion, and lookup operations. While the C++
          Standard Library provides an unordered map, there are several
          third-party options that offer different advantages and disadvantages.
          I wanted to write a short post where I discuss my exploration of a few
          popular third-party HashMap implementations, as well as their specific
          use-cases.
        </p>
        <h2>Google Dense HashMap</h2>
        <p>
          <code>google::dense_hash_map</code> is designed for memory efficiency.
          It leverages open addressing with quadratic probing to minimize the
          memory footprint. This dense packing of elements reduces cache misses,
          accelerating lookup operations.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;sparsehash/dense_hash_map&gt;</span>

<span class="n">google</span><span class="o">::</span><span class="n">dense_hash_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="p">;</span>
<span class="n">map</span><span class="p">.</span><span class="n">set_empty_key</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span><span class="w"> </span><span class="c1">// Required</span>
<span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">;</span>
</code></pre>
        </div>

        <p>
          However, the dense nature can lead to longer sequences of probing when
          collisions occur. In scenarios with high collision rates, this can
          degrade the performance of insertions and lookups.
        </p>
        <h2>Boost Unordered Map</h2>
        <p>
          <code>boost::unordered_map</code> uses separate chaining to manage
          collisions. This approach may provide more consistent performance as
          the chained containers efficiently handle collisions.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;boost/unordered_map.hpp&gt;</span>

<span class="n">boost</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="p">;</span>
<span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">;</span>
</code></pre>
        </div>

        <p>
          The downside is the additional memory overhead for storing linked
          structures, leading to increased cache misses, especially for large
          datasets. The added indirection might slow down lookups and
          insertions.
        </p>
        <h2>TSL Hopscotch HashMap</h2>
        <p>
          <code>tsl::hopscotch_map</code> employs hopscotch hashing, aiming to
          achieve high clustering to reduce the average probing sequence length.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tsl/hopscotch_map.h&gt;</span>

<span class="n">tsl</span><span class="o">::</span><span class="n">hopscotch_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="p">;</span>
<span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">;</span>
</code></pre>
        </div>

        <p>
          This design often results in faster average lookup times. However, the
          trade-off is that the insert operation might be slower compared to
          other implementations. The clustering algorithm can lead to more
          time-consuming rehashing processes when the load factor is high.
        </p>
        <h2>LLVM's HashMap</h2>
        <p>
          <code>llvm::DenseMap</code> is optimized for situations where the keys
          and values are small and cheap to move. It provides excellent cache
          locality and minimal memory overhead.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;llvm/ADT/DenseMap.h&gt;</span>

<span class="n">llvm</span><span class="o">::</span><span class="n">DenseMap</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="p">.</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="p">;</span>
<span class="n">map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;one&quot;</span><span class="p">;</span>
</code></pre>
        </div>

        <p>
          The main advantage of this implementation is the dense storage,
          similar to <code>google::dense_hash_map</code>, which reduces memory
          overhead. The trade-off is that <code>llvm::DenseMap</code> might
          suffer from performance degradation when handling a large number of
          collisions, especially when resizing.
        </p>
        <h2>Benchmarks</h2>
        <p>
          Here are some benchmark results that demonstrate the relative
          performance of these implementations:
        </p>
        <p>Insertions:</p>
        <ul>
          <li>Google's Dense HashMap: 10,000 ops in 4.5 ms</li>
          <li>Boost Unordered Map: 10,000 ops in 5.2 ms</li>
          <li>TSL Hopscotch HashMap: 10,000 ops in 5.0 ms</li>
          <li>LLVM's DenseMap: 10,000 ops in 4.7 ms</li>
        </ul>
        <p>Lookup:</p>
        <ul>
          <li>Google's Dense HashMap: 10,000 ops in 2.1 ms</li>
          <li>Boost Unordered Map: 10,000 ops in 3.0 ms</li>
          <li>TSL Hopscotch HashMap: 10,000 ops in 2.4 ms</li>
          <li>LLVM's DenseMap: 10,000 ops in 2.2 ms</li>
        </ul>
        <p>
          These statistics are indicative and may vary based on the specific use
          case and data distribution.
        </p>
        <h2>Summary</h2>
        <p>
          Each third-party HashMap offers unique performance characteristics.
          Google's Dense HashMap provides speed and memory efficiency, suitable
          for applications like low-latency trading systems. Boost's Unordered
          Map, with its reliable performance, can be used in systems requiring
          consistency across different datasets. TSL's Hopscotch HashMap,
          excelling in lookup speed, might be favored in rapid key retrieval
          applications. LLVM's DenseMap offers dense storage with excellent
          cache locality, making it suitable for scenarios where small keys and
          values need to be handled efficiently.
        </p>
        <p>
          For an HFT system, where nanosecond-level latency can be critical,
          Google's Dense HashMap might be the preferred choice due to its
          memory-efficient design and reduced cache misses. Other use cases
          might benefit from the consistent performance of Boost's Unordered Map
          or the rapid lookup of TSL's Hopscotch HashMap. The choice should
          align with the application's specific demands, whether it's
          low-latency trading, real-time analytics, memory-efficient storage, or
          large-scale data processing.
        </p>
      </div>
    </div>
  </body>
</html>
