<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: #6e7681;
        background-color: #0d1117;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: #6e7681;
        background-color: #0d1117;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #e6edf3;
        background-color: #6e7681;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #e6edf3;
        background-color: #6e7681;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #6e7681;
      }
      .codehilite {
        background: #0d1117;
        color: #e6edf3;
      }
      .codehilite .c {
        color: #8b949e;
        font-style: italic;
      } /* Comment */
      .codehilite .err {
        color: #f85149;
      } /* Error */
      .codehilite .esc {
        color: #e6edf3;
      } /* Escape */
      .codehilite .g {
        color: #e6edf3;
      } /* Generic */
      .codehilite .k {
        color: #ff7b72;
      } /* Keyword */
      .codehilite .l {
        color: #a5d6ff;
      } /* Literal */
      .codehilite .n {
        color: #e6edf3;
      } /* Name */
      .codehilite .o {
        color: #ff7b72;
        font-weight: normal;
      } /* Operator */
      .codehilite .x {
        color: #e6edf3;
      } /* Other */
      .codehilite .p {
        color: #e6edf3;
      } /* Punctuation */
      .codehilite .ch {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #8b949e;
        font-weight: normal;
        font-style: italic;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #8b949e;
        font-style: italic;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Single */
      .codehilite .cs {
        color: #8b949e;
        font-weight: normal;
        font-style: italic;
      } /* Comment.Special */
      .codehilite .gd {
        color: #ffa198;
        background-color: #490202;
      } /* Generic.Deleted */
      .codehilite .ge {
        color: #e6edf3;
        font-style: italic;
      } /* Generic.Emph */
      .codehilite .gr {
        color: #ffa198;
      } /* Generic.Error */
      .codehilite .gh {
        color: #79c0ff;
        font-weight: normal;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #56d364;
        background-color: #0f5323;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #8b949e;
      } /* Generic.Output */
      .codehilite .gp {
        color: #8b949e;
      } /* Generic.Prompt */
      .codehilite .gs {
        color: #e6edf3;
        font-weight: normal;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #79c0ff;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #ff7b72;
      } /* Generic.Traceback */
      .codehilite .g-Underline {
        color: #e6edf3;
        text-decoration: underline;
      } /* Generic.Underline */
      .codehilite .kc {
        color: #79c0ff;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #ff7b72;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #ff7b72;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #79c0ff;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #ff7b72;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #ff7b72;
      } /* Keyword.Type */
      .codehilite .ld {
        color: #79c0ff;
      } /* Literal.Date */
      .codehilite .m {
        color: #a5d6ff;
      } /* Literal.Number */
      .codehilite .s {
        color: #a5d6ff;
      } /* Literal.String */
      .codehilite .na {
        color: #e6edf3;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #e6edf3;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #f0883e;
        font-weight: normal;
      } /* Name.Class */
      .codehilite .no {
        color: #79c0ff;
        font-weight: normal;
      } /* Name.Constant */
      .codehilite .nd {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #ffa657;
      } /* Name.Entity */
      .codehilite .ne {
        color: #f0883e;
        font-weight: normal;
      } /* Name.Exception */
      .codehilite .nf {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Function */
      .codehilite .nl {
        color: #79c0ff;
        font-weight: normal;
      } /* Name.Label */
      .codehilite .nn {
        color: #ff7b72;
      } /* Name.Namespace */
      .codehilite .nx {
        color: #e6edf3;
      } /* Name.Other */
      .codehilite .py {
        color: #79c0ff;
      } /* Name.Property */
      .codehilite .nt {
        color: #7ee787;
      } /* Name.Tag */
      .codehilite .nv {
        color: #79c0ff;
      } /* Name.Variable */
      .codehilite .ow {
        color: #ff7b72;
        font-weight: normal;
      } /* Operator.Word */
      .codehilite .pm {
        color: #e6edf3;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #6e7681;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #a5d6ff;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #a5d6ff;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #a5d6ff;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #a5d6ff;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #a5d6ff;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #79c0ff;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #a5d6ff;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #a5d6ff;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #79c0ff;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #a5d6ff;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #a5d6ff;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #79c0ff;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #79c0ff;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #a5d6ff;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #a5d6ff;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #79c0ff;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #a5d6ff;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #a5d6ff;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #e6edf3;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #79c0ff;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #79c0ff;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #79c0ff;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #79c0ff;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #a5d6ff;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>What exactly is <code>std::tuple</code> in C++?</h1>
        <blockquote>
          <p>May 20, 2023</p>
        </blockquote>
        <p>
          <code>std::tuple</code>, introduced in C++11, is quite an interesting
          container.
        </p>
        <p>
          Why? It doesn't adhere to the conventional traits of STL containers.
          It’s a curious mix of being type agnostic, stack allocated, and
          distinctively different in its interface.
        </p>
        <h2>A Curious Container</h2>
        <p>
          Formally, <code>std::tuple</code> is a template class with an ability
          to encapsulate a collection of heterogeneous values, each potentially
          of a different type, fixed in size. It’s particularly invaluable when
          there’s a need to return multiple values from a function, or when
          dealing with complex data manipulations involving mixed types.
        </p>
        <p>
          Unlike other contiguous containers, like <code>std::vector</code> or
          <code>std::array</code>, <code>std::tuple</code> doesn't define a
          subscript operator for accessing elements by index. Instead, because
          of its type agnostic nature, elements in a <code>std::tuple</code> are
          individually accessible using the
          <code>std::get&lt;I&gt;</code> function, which takes the index of the
          desired element as a template argument.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tuple&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mf">4.5</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
        </div>

        <h2>Looking Under the Hood</h2>
        <p>
          So why is <code>std::tuple</code> so unique as a container? It's the
          byproduct of extensive template-meta programming, especially in
          regards to its type safety.
        </p>
        <p>
          Template metaprogramming allows <code>std::tuple</code> to generate
          code that is tailored to handle these specific types, allowing for
          type safety and stack allocation. Functions like
          <code>std::get&lt;I&gt;</code>, which retrieve elements from a tuple,
          rely on template arguments to deduce the type and index of the element
          at compile time. Recursive template instantiations and specializations
          are often employed to navigate through the tuple's elements, making
          operations like accessing, modifying, and iterating over elements both
          type-safe, yet uniquely implemented.
        </p>
        <p>
          Fundamentally, under the hood, <code>std::tuple</code> can be thought
          of being directly translated to a struct.
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>

<span class="c1">// is equivalent to...</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">tuple</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">element_1</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">element_2</span><span class="p">{</span><span class="s">&quot;Hello World&quot;</span><span class="p">};</span>
<span class="p">};</span>
</code></pre>
        </div>
      </div>
    </div>
  </body>
</html>
