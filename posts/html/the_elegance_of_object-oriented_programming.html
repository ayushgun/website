<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link href="../../static/styles.css" rel="stylesheet" />
    <link href="../../static/highlights.css" rel="stylesheet" />
  </head>
  <body>
    <div class="centered-div">
      <h1>The Elegance of Object-Oriented Paradigms</h1>
      <blockquote>
        <p>June 29, 2023</p>
      </blockquote>
      <p>
        Last summer, I was building a learning management system for my
        non-profit tutoring startup,
        <a href="https://learnforsyth.org">LearnForsyth</a>. Initially, the
        project was small and, like many developers, I thought it would be fine
        to take a procedural approach. However, as the codebase grew, I faced
        difficulties in managing the relationships between workspaces, students,
        and tutors. When I decided to channel my inner
        <a href="https://gt-student-wiki.org/mediawiki/index.php/CS_2340"
          >CS 2340</a
        >
        and follow the OOP paradigm by refactoring the code into classes and
        objects, the structure became much clearer and the codebase more
        maintainable, which was a game-changer for the project.
      </p>
      <p>
        Before delving into why I prefer OOP, let's briefly touch upon
        Functional Programming (FP). FP is a paradigm where the process of
        computation is treated as the evaluation of mathematical functions and
        avoids changing state and mutable data. Here's an example in Haskell, a
        purely functional language:
      </p>
      <div class="codehilite">
        <pre><span></span><code><span class="nf">factorial</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span>
<span class="nf">factorial</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">factorial</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</code></pre>
      </div>

      <p>
        This function computes the factorial of a number using recursion, a
        common technique in FP.
      </p>
      <h2>The Intuitive Nature of Object-Oriented Programming</h2>
      <p>
        In my experience, OOP is inherently intuitive, as it mirrors real-world
        entities and their interactions. The encapsulation principle, a
        cornerstone of OOP, allows for bundling data and methods that operate on
        that data within a single unit, known as a class. For instance, consider
        a simple <code>Car</code> class in C++:
      </p>
      <div class="codehilite">
        <pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Car</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">make</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">make</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">make</span><span class="p">(</span><span class="n">make</span><span class="p">),</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">model</span><span class="p">),</span><span class="w"> </span><span class="n">year</span><span class="p">(</span><span class="n">year</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">honk</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Honk!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
      </div>

      <p>
        This class encapsulates the properties of a car and provides a method to
        honk. The encapsulation principle in OOP is akin to how real-world
        objects have states and behaviors.
      </p>
      <h2>The Power of Polymorphism</h2>
      <p>
        Polymorphism is another pillar of OOP that allows objects of different
        classes to be treated as objects of a common superclass. This feature is
        particularly powerful when designing extensible systems. In C++,
        polymorphism is achieved through inheritance and virtual functions.
        Consider an example where different types of shapes need to be drawn:
      </p>
      <div class="codehilite">
        <pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">draw</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Pure virtual function</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Circle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">draw</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Drawing a circle.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Square</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">draw</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Drawing a square.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
      </div>

      <p>
        With polymorphism, you can create a collection of
        <code>Shape</code> pointers and call the appropriate
        <code>draw</code> method without knowing the actual derived class:
      </p>
      <div class="codehilite">
        <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">shapes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="k">new</span><span class="w"> </span><span class="n">Circle</span><span class="p">(),</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Square</span><span class="p">()};</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">shapes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">shape</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
      </div>

      <h2>The Robustness of Abstraction and Information Hiding</h2>
      <p>
        Abstraction and information hiding are essential for creating robust
        systems. In OOP, classes serve as blueprints, and objects are instances
        of these classes. By using private and protected access specifiers, OOP
        allows for hiding the internal state and requiring interaction through
        well-defined interfaces. This encapsulation ensures that objects
        maintain valid states even in complex systems.
      </p>
      <p>
        In functional programming, while it's possible to achieve abstraction
        using closures and modules, the declarative nature of functional
        programming sometimes leads to a lack of clarity regarding the flow of
        data and state changes, especially in large codebases.
      </p>
      <h2>The Expressiveness of Design Patterns</h2>
      <p>
        OOP is known for its rich set of design patterns, which are reusable
        solutions to common programming problems. Patterns like Singleton,
        Factory, and Observer are widely used in software engineering. These
        patterns are not just code snippets but involve class structures,
        inheritance, and interfaces.
      </p>
      <p>For example, the Observer pattern in C++:</p>
      <div class="codehilite">
        <pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Observer</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ConcreteObserver</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Observer</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">observer_state</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">observer_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Observer state updated to &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">observer_state</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Subject</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Observer</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">observers</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">attach</span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span><span class="w"> </span><span class="n">observer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">observers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">observer</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">set_state</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">new_state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_state</span><span class="p">;</span>
<span class="w">        </span><span class="n">notify_observers</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">notify_observers</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span><span class="w"> </span><span class="n">observer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">observers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">observer</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
      </div>

      <p>
        In this example, the Observer pattern allows objects to observe changes
        in another object's state. This pattern is expressive and aligns well
        with OOP principles.
      </p>
      <p>
        Functional programming, on the other hand, tends to rely on function
        composition and recursion. While functional programming has its own set
        of patterns, they are often less expressive when it comes to modeling
        complex interactions between objects. For instance, in Haskell, you
        might use higher-order functions to achieve similar behavior:
      </p>
      <div class="codehilite">
        <pre><span></span><code><span class="kr">type</span><span class="w"> </span><span class="kt">Observer</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>

<span class="nf">notifyObservers</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Observer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">notifyObservers</span><span class="w"> </span><span class="n">observers</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mapM_</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">observer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">observer</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="n">observers</span>
</code></pre>
      </div>

      <p>
        While this functional approach is concise, it lacks the expressiveness
        and structure provided by the OOP approach.
      </p>
      <h1>Conclusion</h1>
      <p>
        While functional programming has its merits, especially in concurrency
        and stateless computation, the intuitive nature, polymorphism, robust
        abstraction, and expressive design patterns of Object-Oriented
        Programming make it a more appealing choice for many software
        engineering tasks. The ability to model real-world entities and their
        interactions in an intuitive and modular way is where OOP shines, and
        this is why I personally prefer OOP paradigms over functional
        programming paradigms.
      </p>
    </div>
  </body>
</html>
