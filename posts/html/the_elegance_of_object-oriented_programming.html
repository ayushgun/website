<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: #6e7681;
        background-color: #0d1117;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: #6e7681;
        background-color: #0d1117;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #e6edf3;
        background-color: #6e7681;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #e6edf3;
        background-color: #6e7681;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #6e7681;
      }
      .codehilite {
        background: #0d1117;
        color: #e6edf3;
      }
      .codehilite .c {
        color: #8b949e;
        font-style: italic;
      } /* Comment */
      .codehilite .err {
        color: #f85149;
      } /* Error */
      .codehilite .esc {
        color: #e6edf3;
      } /* Escape */
      .codehilite .g {
        color: #e6edf3;
      } /* Generic */
      .codehilite .k {
        color: #ff7b72;
      } /* Keyword */
      .codehilite .l {
        color: #a5d6ff;
      } /* Literal */
      .codehilite .n {
        color: #e6edf3;
      } /* Name */
      .codehilite .o {
        color: #ff7b72;
        font-weight: normal;
      } /* Operator */
      .codehilite .x {
        color: #e6edf3;
      } /* Other */
      .codehilite .p {
        color: #e6edf3;
      } /* Punctuation */
      .codehilite .ch {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #8b949e;
        font-weight: normal;
        font-style: italic;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #8b949e;
        font-style: italic;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Single */
      .codehilite .cs {
        color: #8b949e;
        font-weight: normal;
        font-style: italic;
      } /* Comment.Special */
      .codehilite .gd {
        color: #ffa198;
        background-color: #490202;
      } /* Generic.Deleted */
      .codehilite .ge {
        color: #e6edf3;
        font-style: italic;
      } /* Generic.Emph */
      .codehilite .gr {
        color: #ffa198;
      } /* Generic.Error */
      .codehilite .gh {
        color: #79c0ff;
        font-weight: normal;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #56d364;
        background-color: #0f5323;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #8b949e;
      } /* Generic.Output */
      .codehilite .gp {
        color: #8b949e;
      } /* Generic.Prompt */
      .codehilite .gs {
        color: #e6edf3;
        font-weight: normal;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #79c0ff;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #ff7b72;
      } /* Generic.Traceback */
      .codehilite .g-Underline {
        color: #e6edf3;
        text-decoration: underline;
      } /* Generic.Underline */
      .codehilite .kc {
        color: #79c0ff;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #ff7b72;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #ff7b72;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #79c0ff;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #ff7b72;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #ff7b72;
      } /* Keyword.Type */
      .codehilite .ld {
        color: #79c0ff;
      } /* Literal.Date */
      .codehilite .m {
        color: #a5d6ff;
      } /* Literal.Number */
      .codehilite .s {
        color: #a5d6ff;
      } /* Literal.String */
      .codehilite .na {
        color: #e6edf3;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #e6edf3;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #f0883e;
        font-weight: normal;
      } /* Name.Class */
      .codehilite .no {
        color: #79c0ff;
        font-weight: normal;
      } /* Name.Constant */
      .codehilite .nd {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #ffa657;
      } /* Name.Entity */
      .codehilite .ne {
        color: #f0883e;
        font-weight: normal;
      } /* Name.Exception */
      .codehilite .nf {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Function */
      .codehilite .nl {
        color: #79c0ff;
        font-weight: normal;
      } /* Name.Label */
      .codehilite .nn {
        color: #ff7b72;
      } /* Name.Namespace */
      .codehilite .nx {
        color: #e6edf3;
      } /* Name.Other */
      .codehilite .py {
        color: #79c0ff;
      } /* Name.Property */
      .codehilite .nt {
        color: #7ee787;
      } /* Name.Tag */
      .codehilite .nv {
        color: #79c0ff;
      } /* Name.Variable */
      .codehilite .ow {
        color: #ff7b72;
        font-weight: normal;
      } /* Operator.Word */
      .codehilite .pm {
        color: #e6edf3;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #6e7681;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #a5d6ff;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #a5d6ff;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #a5d6ff;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #a5d6ff;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #a5d6ff;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #79c0ff;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #a5d6ff;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #a5d6ff;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #79c0ff;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #a5d6ff;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #a5d6ff;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #79c0ff;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #79c0ff;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #a5d6ff;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #a5d6ff;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #79c0ff;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #a5d6ff;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #a5d6ff;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #e6edf3;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #79c0ff;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #79c0ff;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #79c0ff;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #79c0ff;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #a5d6ff;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>The Elegance of Object-Oriented Paradigms</h1>
        <blockquote>
          <p>June 29, 2023</p>
        </blockquote>
        <p>
          Last summer, I was building a learning management system for my
          non-profit tutoring startup,
          <a href="https://learnforsyth.org">LearnForsyth</a>. Initially, the
          project was small and, like many developers, I thought it would be
          fine to take a procedural approach. However, as the codebase grew, I
          faced difficulties in managing the relationships between workspaces,
          students, and tutors. When I decided to channel my inner
          <a href="https://gt-student-wiki.org/mediawiki/index.php/CS_2340"
            >CS 2340</a
          >
          and follow the OOP paradigm by refactoring the code into classes and
          objects, the structure became much clearer and the codebase more
          maintainable, which was a game-changer for the project.
        </p>
        <p>
          Before delving into why I think OOP is more suitable for most use
          cases, let's define its counterpart –– Functional Programming (FP). FP
          is a paradigm where the process of computation is treated as the
          evaluation of mathematical functions and avoids changing state and
          mutable data. Here's an example in Haskell, a purely functional
          language:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="nf">factorial</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Integer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Integer</span>
<span class="nf">factorial</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">factorial</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
</code></pre>
        </div>

        <p>
          This function computes the factorial of a number using recursion, a
          common technique in FP.
        </p>
        <h2>The Intuitive Nature of Object-Oriented Programming</h2>
        <p>
          In my experience, OOP is inherently intuitive, as it mirrors
          real-world entities and their interactions. The encapsulation
          principle, a cornerstone of OOP, allows for bundling data and methods
          that operate on that data within a single unit, known as a class. For
          instance, consider a simple <code>Car</code> class in C++:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Car</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">make</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Car</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">make</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">year</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">make</span><span class="p">(</span><span class="n">make</span><span class="p">),</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">model</span><span class="p">),</span><span class="w"> </span><span class="n">year</span><span class="p">(</span><span class="n">year</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">honk</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Honk!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
        </div>

        <p>
          This class encapsulates the properties of a car and provides a method
          to honk. The encapsulation principle in OOP is akin to how real-world
          objects have states and behaviors.
        </p>
        <h2>The Power of Polymorphism</h2>
        <p>
          Polymorphism is another pillar of OOP that allows objects of different
          classes to be treated as objects of a common superclass. This feature
          is particularly powerful when designing extensible systems. In C++,
          polymorphism is achieved through inheritance and virtual functions.
          Consider an example where different types of shapes need to be drawn:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">draw</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Circle</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">draw</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Drawing a circle.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Square</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Shape</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">draw</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Drawing a square.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
        </div>

        <p>
          With polymorphism, you can create a collection of
          <code>Shape</code> pointers and call the appropriate
          <code>draw</code> method without knowing the actual derived class:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">shapes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="k">new</span><span class="w"> </span><span class="n">Circle</span><span class="p">(),</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Square</span><span class="p">()};</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Shape</span><span class="o">*</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">shapes</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">shape</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
        </div>

        <h2>The Robustness of Abstraction and Information Hiding</h2>
        <p>
          Abstraction and information hiding are essential for creating robust
          systems. In OOP, classes serve as blueprints, and objects are
          instances of these classes. By using private and protected access
          specifiers, OOP allows for hiding the internal state and requiring
          interaction through well-defined interfaces. This encapsulation
          ensures that objects maintain valid states even in complex systems.
        </p>
        <p>
          In functional programming, while it's possible to achieve abstraction
          using closures and modules, the declarative nature of functional
          programming sometimes leads to a lack of clarity regarding the flow of
          data and state changes, especially in large codebases.
        </p>
        <h2>The Expressiveness of Design Patterns</h2>
        <p>
          OOP is known for its rich set of design patterns, which are reusable
          solutions to common programming problems. Patterns like Singleton,
          Factory, and Observer are widely used in software engineering. These
          patterns are not just code snippets but involve class structures,
          inheritance, and interfaces.
        </p>
        <p>For example, the Observer pattern in C++:</p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Observer</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ConcreteObserver</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Observer</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">observer_state</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">update</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">observer_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Observer state updated to: &quot;</span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">observer_state</span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Subject</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Observer</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">observers</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">attach</span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span><span class="w"> </span><span class="n">observer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">observers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">observer</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">set_state</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">new_state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_state</span><span class="p">;</span>
<span class="w">        </span><span class="n">notify_observers</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">notify_observers</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Observer</span><span class="o">*</span><span class="w"> </span><span class="n">observer</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">observers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">observer</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre>
        </div>

        <p>
          In this example, the Observer pattern allows objects to observe
          changes in another object's state. This pattern is expressive and
          aligns well with OOP principles.
        </p>
        <p>
          Functional programming, on the other hand, tends to rely on function
          composition and recursion. While functional programming has its own
          set of patterns, they are often less expressive when it comes to
          modeling complex interactions between objects. For instance, in
          Haskell, you might use higher-order functions to achieve similar
          behavior:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="kr">type</span><span class="w"> </span><span class="kt">Observer</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>

<span class="nf">notifyObservers</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">[</span><span class="kt">Observer</span><span class="p">]</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="nb">()</span>
<span class="nf">notifyObservers</span><span class="w"> </span><span class="n">observers</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="n">mapM_</span><span class="w"> </span><span class="p">(</span><span class="nf">\</span><span class="n">observer</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">observer</span><span class="w"> </span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="n">observers</span>
</code></pre>
        </div>

        <p>
          While this functional approach is concise, it lacks the expressiveness
          and structure provided by the OOP approach.
        </p>
        <h1>Conclusion</h1>
        <p>
          While functional programming has its merits, especially in concurrency
          and stateless computation, the intuitive nature, polymorphism, robust
          abstraction, and expressive design patterns of Object-Oriented
          Programming make it a more appealing choice for many software
          engineering tasks. The ability to model real-world entities and their
          interactions in an intuitive and modular way is where OOP shines, and
          this is why I personally prefer OOP paradigms over functional
          programming paradigms.
        </p>
      </div>
    </div>
  </body>
</html>
