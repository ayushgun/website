<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: inherit;
        background-color: transparent;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: inherit;
        background-color: transparent;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #000000;
        background-color: #ffffc0;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #000000;
        background-color: #ffffc0;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #ffffcc;
      }
      .codehilite {
        background: #282c34;
        color: #abb2bf;
      }
      .codehilite .c {
        color: #7f848e;
      } /* Comment */
      .codehilite .err {
        color: #abb2bf;
      } /* Error */
      .codehilite .esc {
        color: #abb2bf;
      } /* Escape */
      .codehilite .g {
        color: #abb2bf;
      } /* Generic */
      .codehilite .k {
        color: #c678dd;
      } /* Keyword */
      .codehilite .l {
        color: #abb2bf;
      } /* Literal */
      .codehilite .n {
        color: #e06c75;
      } /* Name */
      .codehilite .o {
        color: #56b6c2;
      } /* Operator */
      .codehilite .x {
        color: #abb2bf;
      } /* Other */
      .codehilite .p {
        color: #abb2bf;
      } /* Punctuation */
      .codehilite .ch {
        color: #7f848e;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #7f848e;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #7f848e;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #7f848e;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #7f848e;
      } /* Comment.Single */
      .codehilite .cs {
        color: #7f848e;
      } /* Comment.Special */
      .codehilite .gd {
        color: #abb2bf;
      } /* Generic.Deleted */
      .codehilite .ge {
        color: #abb2bf;
      } /* Generic.Emph */
      .codehilite .ges {
        color: #abb2bf;
      } /* Generic.EmphStrong */
      .codehilite .gr {
        color: #abb2bf;
      } /* Generic.Error */
      .codehilite .gh {
        color: #abb2bf;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #abb2bf;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #abb2bf;
      } /* Generic.Output */
      .codehilite .gp {
        color: #abb2bf;
      } /* Generic.Prompt */
      .codehilite .gs {
        color: #abb2bf;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #abb2bf;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #abb2bf;
      } /* Generic.Traceback */
      .codehilite .kc {
        color: #e5c07b;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #c678dd;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #c678dd;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #c678dd;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #c678dd;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #e5c07b;
      } /* Keyword.Type */
      .codehilite .ld {
        color: #abb2bf;
      } /* Literal.Date */
      .codehilite .m {
        color: #d19a66;
      } /* Literal.Number */
      .codehilite .s {
        color: #98c379;
      } /* Literal.String */
      .codehilite .na {
        color: #e06c75;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #e5c07b;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #e5c07b;
      } /* Name.Class */
      .codehilite .no {
        color: #e06c75;
      } /* Name.Constant */
      .codehilite .nd {
        color: #61afef;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #e06c75;
      } /* Name.Entity */
      .codehilite .ne {
        color: #e06c75;
      } /* Name.Exception */
      .codehilite .nf {
        color: #61afef;
        font-weight: normal;
      } /* Name.Function */
      .codehilite .nl {
        color: #e06c75;
      } /* Name.Label */
      .codehilite .nn {
        color: #e06c75;
      } /* Name.Namespace */
      .codehilite .nx {
        color: #e06c75;
      } /* Name.Other */
      .codehilite .py {
        color: #e06c75;
      } /* Name.Property */
      .codehilite .nt {
        color: #e06c75;
      } /* Name.Tag */
      .codehilite .nv {
        color: #e06c75;
      } /* Name.Variable */
      .codehilite .ow {
        color: #56b6c2;
      } /* Operator.Word */
      .codehilite .pm {
        color: #abb2bf;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #abb2bf;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #d19a66;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #d19a66;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #d19a66;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #d19a66;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #d19a66;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #98c379;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #98c379;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #98c379;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #98c379;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #98c379;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #98c379;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #98c379;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #98c379;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #98c379;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #98c379;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #98c379;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #98c379;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #98c379;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #e5c07b;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #56b6c2;
        font-weight: normal;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #e06c75;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #e06c75;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #e06c75;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #e06c75;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #d19a66;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>Compile-Time Bounds Checking</h1>
        <blockquote>
          <p>March 26, 2024</p>
        </blockquote>
        <p>
          When working with contiguous containers in C++, such as
          <code>std::vector</code>, it's common to use bounds-checked interfaces
          like the <code>at()</code> member function to ensure safety from
          undefined behavior or undesirable side effects. However, these
          interfaces come with a trade-off: they introduce a run-time penalty
          due to the necessity of checking bounds at run-time. Moreover, they
          rely on exceptions to signal out-of-bounds access, further adding
          overhead.
        </p>
        <h2>Current Bounds Checking</h2>
        <p>
          What if we could perform bounds checking at compile-time instead?
          Compilers can statically prove that a bounds check will always pass,
          allowing them to omit the checking code entirely. For example,
          consider the following code:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          In this case, the compiler knows that the array always has ten
          elements, and we're asking for the element at index zero. Therefore,
          it knows that it can remove the bounds check and unconditionally
          return the first element of the array.
        </p>
        <p>
          Similarly, when the bounds check is certain to fail, the compiler can
          generate code that unconditionally throws an exception:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">// throws std::out_of_range</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          What if we could similarly leverage this compile-time information to
          turn these run-time exceptions into compile-time errors?
        </p>
        <h2>Implementing Compile-Time Bounds Checking</h2>
        <p>
          To achieve compile-time bounds checking, we can exploit the GCC
          compiler extension <code>__builtin_constant_p</code>, which returns
          whether the compiler knows an (potentially run-time) expression to be
          a constant at compile-time. We can use this to check if a given
          <code>index</code> and <code>limit</code> are known at compile-time
          and trigger a compile-time error if a bounds violation is detected.
        </p>
        <p>
          But how can we intentionally trigger a compilation error? We can't use
          <code>static_assert</code> or similar constructs, as they would always
          fail unconditionally. Since we're not working with expressions that
          C++ regards as compile-time constants, such as template parameters or
          <code>constexpr</code> variables, where we could apply
          <code>static_assert</code> or <code>if constexpr</code>. Instead,
          we're dealing with expressions considered by the language to be
          run-time values — even though the optimizer might have additional
          information about them.
        </p>
        <p>
          The solution is to utilize another compiler extension, the
          <code>gcc::error</code> attribute. If we enable optimizations,
          compilation will fail if the <code>failed_bounds_check</code> call is
          not optimized out. The cherry on top is that, at least with GCC, we
          get a compiler backtrace that precisely identifies the location of the
          original problematic code, even through a lengthy series of inlined
          functions.
        </p>
        <p>Here's what it looks like:</p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">IndexType</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">bounds_check</span><span class="p">(</span><span class="n">IndexType</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">IndexType</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">IndexType</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">[[</span><span class="n">gnu</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;out-of-bounds&quot;</span><span class="p">)]]</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">failed_bounds_check</span><span class="p">();</span>
<span class="w">      </span><span class="n">failed_bounds_check</span><span class="p">();</span><span class="w">  </span><span class="c1">// Trigger the compile-time error if the call is</span>
<span class="w">                              </span><span class="c1">// not optimized away</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre>
        </div>

        <h2>Generic Interfaces</h2>
        <p>
          If we use concepts, we can generalize our compile-time bounds checked
          interface to any
          <a
            href="https://en.cppreference.com/w/cpp/named_req/ContiguousContainer"
            >contiguous container</a
          >:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Container</span><span class="o">&gt;</span>
<span class="k">concept</span><span class="w"> </span><span class="nc">ContiguousContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">requires</span><span class="p">(</span><span class="n">Container</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Container</span><span class="o">::</span><span class="n">value_type</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">convertible_to</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Container</span><span class="o">::</span><span class="n">value_type</span><span class="o">*&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">ContiguousContainer</span><span class="w"> </span><span class="n">Container</span><span class="o">&gt;</span>
<span class="k">typename</span><span class="w"> </span><span class="nc">Container</span><span class="o">::</span><span class="n">value_type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span><span class="w"> </span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">idx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">bounds_check</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">container</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          This allows us to use the get function with any container that
          satisfies the <code>ContiguousContainer</code> concept:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">);</span><span class="w">  </span><span class="c1">// error: call to ‘failed_bounds_check’ declared</span>
<span class="w">                           </span><span class="c1">// with attribute error: out-of-bounds</span>
</code></pre>
        </div>

        <h2>Known Limitations</h2>
        <p>
          Of course, this approach has its limitations. Aside from requiring
          compiler extensions to be enabled, it needs <code>-O1</code> (or
          higher) optimizations to be enabled so the
          <code>failed_bounds_check</code> call can potentially be optimized
          away.
        </p>
        <h2>Resources</h2>
        <ul>
          <li>
            <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html"
              >GCC built-in documentation</a
            >
          </li>
          <li>
            <a href="https://github.com/tcbrindle/flux"
              >Tristan Brindle's <code>flux</code> library</a
            >
            uses a similar technique, which served as the inspiration for the
            idea of generalized static bounds-checked interfaces
          </li>
        </ul>
      </div>
    </div>
  </body>
</html>
