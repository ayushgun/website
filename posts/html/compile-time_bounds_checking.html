<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: #d8dee9;
        background-color: #242933;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: #d8dee9;
        background-color: #242933;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #242933;
        background-color: #d8dee9;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #242933;
        background-color: #d8dee9;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #3b4252;
      }
      .codehilite {
        background: #2e3440;
        color: #d8dee9;
      }
      .codehilite .c {
        color: #616e87;
        font-style: italic;
      } /* Comment */
      .codehilite .err {
        color: #bf616a;
      } /* Error */
      .codehilite .esc {
        color: #d8dee9;
      } /* Escape */
      .codehilite .g {
        color: #d8dee9;
      } /* Generic */
      .codehilite .k {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword */
      .codehilite .l {
        color: #d8dee9;
      } /* Literal */
      .codehilite .n {
        color: #d8dee9;
      } /* Name */
      .codehilite .o {
        color: #81a1c1;
        font-weight: normal;
      } /* Operator */
      .codehilite .x {
        color: #d8dee9;
      } /* Other */
      .codehilite .p {
        color: #eceff4;
      } /* Punctuation */
      .codehilite .ch {
        color: #616e87;
        font-style: italic;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #616e87;
        font-style: italic;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #5e81ac;
        font-style: italic;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #616e87;
        font-style: italic;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #616e87;
        font-style: italic;
      } /* Comment.Single */
      .codehilite .cs {
        color: #616e87;
        font-style: italic;
      } /* Comment.Special */
      .codehilite .gd {
        color: #bf616a;
      } /* Generic.Deleted */
      .codehilite .ge {
        color: #d8dee9;
        font-style: italic;
      } /* Generic.Emph */
      .codehilite .ges {
        color: #d8dee9;
        font-weight: normal;
        font-style: italic;
      } /* Generic.EmphStrong */
      .codehilite .gr {
        color: #bf616a;
      } /* Generic.Error */
      .codehilite .gh {
        color: #88c0d0;
        font-weight: normal;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #a3be8c;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #d8dee9;
      } /* Generic.Output */
      .codehilite .gp {
        color: #616e88;
        font-weight: normal;
      } /* Generic.Prompt */
      .codehilite .gs {
        color: #d8dee9;
        font-weight: normal;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #88c0d0;
        font-weight: normal;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #bf616a;
      } /* Generic.Traceback */
      .codehilite .kc {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #81a1c1;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #81a1c1;
        font-weight: normal;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #81a1c1;
      } /* Keyword.Type */
      .codehilite .ld {
        color: #d8dee9;
      } /* Literal.Date */
      .codehilite .m {
        color: #b48ead;
      } /* Literal.Number */
      .codehilite .s {
        color: #a3be8c;
      } /* Literal.String */
      .codehilite .na {
        color: #8fbcbb;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #81a1c1;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #8fbcbb;
      } /* Name.Class */
      .codehilite .no {
        color: #8fbcbb;
      } /* Name.Constant */
      .codehilite .nd {
        color: #d08770;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #d08770;
      } /* Name.Entity */
      .codehilite .ne {
        color: #bf616a;
      } /* Name.Exception */
      .codehilite .nf {
        color: #88c0d0;
      } /* Name.Function */
      .codehilite .nl {
        color: #d8dee9;
      } /* Name.Label */
      .codehilite .nn {
        color: #8fbcbb;
      } /* Name.Namespace */
      .codehilite .nx {
        color: #d8dee9;
      } /* Name.Other */
      .codehilite .py {
        color: #d8dee9;
      } /* Name.Property */
      .codehilite .nt {
        color: #81a1c1;
      } /* Name.Tag */
      .codehilite .nv {
        color: #d8dee9;
      } /* Name.Variable */
      .codehilite .ow {
        color: #81a1c1;
        font-weight: normal;
      } /* Operator.Word */
      .codehilite .pm {
        color: #eceff4;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #d8dee9;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #b48ead;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #b48ead;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #b48ead;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #b48ead;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #b48ead;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #a3be8c;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #a3be8c;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #a3be8c;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #a3be8c;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #616e87;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #a3be8c;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #ebcb8b;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #a3be8c;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #a3be8c;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #a3be8c;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #ebcb8b;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #a3be8c;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #a3be8c;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #81a1c1;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #88c0d0;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #d8dee9;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #d8dee9;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #d8dee9;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #d8dee9;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #b48ead;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>Compile-Time Bounds Checking</h1>
        <blockquote>
          <p>March 26, 2024</p>
        </blockquote>
        <p>
          When working with random access containers in C++, such as
          <code>std::vector</code>, using bounds-checked interfaces like the
          <code>at()</code> member function ensures safety from undefined
          behavior. However, these interfaces introduce a run-time penalty due
          to the necessity of checking bounds at run-time and relying on
          exceptions to signal out-of-bounds access.
        </p>
        <h2>Current Bounds Checking</h2>
        <p>
          What if we could perform bounds checking at compile-time instead?
          Compilers can statically prove that a bounds check will always pass,
          allowing them to omit the checking code entirely. Consider the
          following code:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          Here, the compiler knows the array always has ten elements and can
          remove the bounds check, returning the first element unconditionally.
        </p>
        <p>
          Similarly, when the bounds check is certain to fail, the compiler can
          generate code that
          <a href="https://godbolt.org/z/94K457E7x"
            >unconditionally throws an exception</a
          >:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">// throws std::out_of_range</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          What if we could leverage this compile-time information to turn these
          run-time exceptions into compile-time errors?
        </p>
        <h2>Implementing Compile-Time Bounds Checking</h2>
        <p>
          We can exploit the GCC compiler extension
          <code>__builtin_constant_p</code>, which returns whether the compiler
          knows a run-time expression to be a constant at compile-time. We can
          use this to check if a given <code>index</code> and
          <code>limit</code> are known at compile-time and trigger a
          compile-time error if a bounds violation is detected.
        </p>
        <p>
          To intentionally trigger a compilation error, we utilize the
          <code>gcc::error</code> attribute. With optimizations enabled,
          compilation will fail if the <code>failed_bounds_check</code> call is
          not optimized away and provide a compiler backtrace that identifies
          the location of the original problematic code.
        </p>
        <p>Here's what it looks like:</p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">IndexType</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">bounds_check</span><span class="p">(</span><span class="n">IndexType</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">IndexType</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">IndexType</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="p">[[</span><span class="n">gnu</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;out-of-bounds&quot;</span><span class="p">)]]</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">failed_bounds_check</span><span class="p">();</span>
<span class="w">      </span><span class="n">failed_bounds_check</span><span class="p">();</span><span class="w">  </span><span class="c1">// Triggers the compile-time error if the call is not optimized away</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre>
        </div>

        <h2>Generic Interface</h2>
        <p>
          Using concepts, we can generalize our compile-time bounds-checked
          interface to any random access container:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Container</span><span class="o">&gt;</span>
<span class="k">concept</span><span class="w"> </span><span class="nc">IndexedContainer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">requires</span><span class="p">(</span><span class="n">Container</span><span class="w"> </span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">container</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">IndexedContainer</span><span class="w"> </span><span class="n">Container</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">bounds_check</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">container</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">container</span><span class="p">)[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          This allows us to use the <code>get</code> template function with any
          container that satisfies the <code>IndexedContainer</code> concept:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">);</span><span class="w">  </span><span class="c1">// error: call to ‘failed_bounds_check’ declared with attribute error: out-of-bounds</span>
</code></pre>
        </div>

        <h2>Known Limitations</h2>
        <p>
          This approach requires compiler extensions to be enabled and
          optimizations (<code>-O1</code> or higher) so the
          <code>failed_bounds_check</code> call can potentially be optimized
          away.
        </p>
        <h2>Resources</h2>
        <ul>
          <li>
            <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html"
              >GCC built-in documentation</a
            >
          </li>
          <li>
            <a href="https://github.com/tcbrindle/flux"
              >Tristan Brindle's <code>flux</code> library</a
            >
            uses a similar technique and served as the inspiration for
            generalized static bounds-checked interfaces.
          </li>
        </ul>
      </div>
    </div>
  </body>
</html>
