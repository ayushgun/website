<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: inherit;
        background-color: transparent;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: inherit;
        background-color: transparent;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #000000;
        background-color: #ffffc0;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #000000;
        background-color: #ffffc0;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #ffffcc;
      }
      .codehilite {
        background: #ffffff;
      }
      .codehilite .c {
        color: #888888;
        font-style: normal;
      } /* Comment */
      .codehilite .err {
        background-color: #a848a8;
      } /* Error */
      .codehilite .k {
        color: #2838b0;
      } /* Keyword */
      .codehilite .o {
        color: #666666;
      } /* Operator */
      .codehilite .p {
        color: #888888;
      } /* Punctuation */
      .codehilite .ch {
        color: #287088;
        font-style: normal;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #888888;
        font-style: normal;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #289870;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #888888;
        font-style: normal;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #888888;
        font-style: normal;
      } /* Comment.Single */
      .codehilite .cs {
        color: #888888;
        font-style: normal;
      } /* Comment.Special */
      .codehilite .gd {
        color: #c02828;
      } /* Generic.Deleted */
      .codehilite .ge {
        font-style: normal;
      } /* Generic.Emph */
      .codehilite .ges {
        font-weight: normal;
        font-style: normal;
      } /* Generic.EmphStrong */
      .codehilite .gr {
        color: #c02828;
      } /* Generic.Error */
      .codehilite .gh {
        color: #666666;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #388038;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #666666;
      } /* Generic.Output */
      .codehilite .gp {
        color: #444444;
      } /* Generic.Prompt */
      .codehilite .gs {
        font-weight: normal;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #444444;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #2838b0;
      } /* Generic.Traceback */
      .codehilite .kc {
        color: #444444;
        font-style: normal;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #2838b0;
        font-style: normal;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #2838b0;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #2838b0;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #2838b0;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #2838b0;
        font-style: normal;
      } /* Keyword.Type */
      .codehilite .m {
        color: #444444;
      } /* Literal.Number */
      .codehilite .s {
        color: #b83838;
      } /* Literal.String */
      .codehilite .na {
        color: #388038;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #388038;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #287088;
      } /* Name.Class */
      .codehilite .no {
        color: #b85820;
      } /* Name.Constant */
      .codehilite .nd {
        color: #287088;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #709030;
      } /* Name.Entity */
      .codehilite .ne {
        color: #908828;
      } /* Name.Exception */
      .codehilite .nf {
        color: #785840;
      } /* Name.Function */
      .codehilite .nl {
        color: #289870;
      } /* Name.Label */
      .codehilite .nn {
        color: #289870;
      } /* Name.Namespace */
      .codehilite .nt {
        color: #2838b0;
      } /* Name.Tag */
      .codehilite .nv {
        color: #b04040;
      } /* Name.Variable */
      .codehilite .ow {
        color: #a848a8;
      } /* Operator.Word */
      .codehilite .pm {
        color: #888888;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #a89028;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #444444;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #444444;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #444444;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #444444;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #444444;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #444444;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #b83838;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #a848a8;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #b85820;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #b85820;
        font-style: normal;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #b83838;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #709030;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #b83838;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #b83838;
        text-decoration: underline;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #a848a8;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #a848a8;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #b83838;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #b83838;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #388038;
        font-style: normal;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #b85820;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #b04040;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #908828;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #b04040;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #b85820;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #444444;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
    <title>Ayush Gundawar &mdash; Post</title>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>Compile-Time Bounds Checking</h1>
        <blockquote>
          <p>March 26, 2024</p>
        </blockquote>
        <p>
          When working with random access containers in C++, such as
          <code>std::vector</code>, using bounds-checked interfaces like the
          <code>at()</code> member function ensures safety from undefined
          behavior. However, these interfaces introduce a run-time penalty due
          to the necessity of checking bounds at run-time and relying on
          exceptions to signal out-of-bounds access.
        </p>
        <h2>Current Bounds Checking</h2>
        <p>
          What if we could perform bounds checking at compile-time instead?
          Compilers can statically prove that a bounds check will always pass
          when they have enough information about the container, allowing them
          to omit the checking code entirely. Consider the following code:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          Here, the compiler knows the array always has ten elements and can
          remove the bounds check, returning the first element unconditionally.
        </p>
        <p>
          Similarly, when the bounds check is certain to fail, the compiler can
          generate code that
          <a href="https://godbolt.org/z/94K457E7x"
            >unconditionally throws an exception</a
          >:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">array</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">  </span><span class="c1">// throws std::out_of_range</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          What if we could leverage the compiler's understanding of this static
          information to turn these run-time exceptions into compile-time
          errors?
        </p>
        <h2>Implementing Compile-Time Bounds Checking</h2>
        <p>
          We can exploit the GCC compiler extension
          <code>__builtin_constant_p</code>, which returns whether the compiler
          knows a run-time expression to be a constant at compile-time [0]. We
          can use this to check if a given <code>index</code> and
          <code>limit</code> are known at compile-time and trigger a
          compile-time error if a bounds violation is detected.
        </p>
        <p>
          To intentionally trigger a compilation error, we utilize the
          <code>gcc::error</code> attribute. With optimizations enabled,
          compilation will fail if the <code>failed_bounds_check</code> call is
          not optimized away and provide a compiler backtrace that identifies
          the location of the original problematic code [1].
        </p>
        <p>Here's what it looks like:</p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">integral</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">check_bounds</span><span class="p">(</span><span class="n">I</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">I</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">[[</span><span class="n">gnu</span><span class="o">::</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;out-of-bounds&quot;</span><span class="p">)]]</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">failed_bounds_check</span><span class="p">();</span>
<span class="w">      </span><span class="n">failed_bounds_check</span><span class="p">();</span><span class="w">  </span><span class="c1">// Triggers the compile-time error if the call is not optimized away</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre>
        </div>

        <h2>Generic Interface</h2>
        <p>
          Using concepts, we can generalize our compile-time bounds-checked
          interface to any random access container:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">random_access_range</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">const_reference</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">check_bounds</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">container</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">container</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">random_access_range</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">constexpr</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="w"> </span><span class="n">container</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">::</span><span class="n">reference</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">check_bounds</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">container</span><span class="p">));</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">container</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          This allows us to use the <code>get</code> template function with any
          container that satisfies the <code>IndexedContainer</code> concept:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre>
        </div>

        <p>If we attempt to compile this:</p>
        <div class="codehilite">
          <pre><span></span><code>$<span class="w"> </span>g++<span class="w"> </span>src/main.cpp<span class="w"> </span>-std<span class="o">=</span>c++20<span class="w"> </span>-O1
In<span class="w"> </span><span class="k">function</span><span class="w"> </span><span class="s1">&#39;constexpr void check_bounds(I, I) [with I = long unsigned int]&#39;</span>,
<span class="w">    </span>inlined<span class="w"> </span>from<span class="w"> </span><span class="s1">&#39;constexpr typename T::reference get(T&amp;, std::size_t) [with T = std::__cxx11::basic_string&lt;char&gt;]&#39;</span><span class="w"> </span>at<span class="w"> </span>src/main.cpp:29:15,
<span class="w">    </span>inlined<span class="w"> </span>from<span class="w"> </span><span class="s1">&#39;int main()&#39;</span><span class="w"> </span>at<span class="w"> </span>src/main.cpp:35:6:
src/main.cpp:12:26:<span class="w"> </span>error:<span class="w"> </span>call<span class="w"> </span>to<span class="w"> </span><span class="s1">&#39;failed_bounds_check&#39;</span><span class="w"> </span>declared<span class="w"> </span>with<span class="w"> </span>attribute<span class="w"> </span>error:<span class="w"> </span>out-of-bounds
<span class="w">   </span><span class="m">12</span><span class="w"> </span><span class="p">|</span><span class="w">       </span>failed_bounds_check<span class="o">()</span><span class="p">;</span><span class="w">  </span>//<span class="w"> </span>Triggers<span class="w"> </span>the<span class="w"> </span>compile-time<span class="w"> </span>error<span class="w"> </span><span class="k">if</span><span class="w"> </span>the<span class="w"> </span>call<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>optimized<span class="w"> </span>away
<span class="w">      </span><span class="p">|</span><span class="w">       </span>~~~~~~~~~~~~~~~~~~~^~
</code></pre>
        </div>

        <h2>Known Limitations</h2>
        <p>
          This approach requires compiler extensions to be enabled and
          optimizations (<code>-O1</code> or higher) so the
          <code>failed_bounds_check</code> call can potentially be optimized
          away.
        </p>
        <h2>Resources</h2>
        <p>
          [0]
          <a href="https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html"
            >https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html</a
          >
        </p>
        <p>
          [1]
          <a href="https://github.com/tcbrindle/flux"
            >https://github.com/tcbrindle/flux</a
          >
        </p>
      </div>
    </div>
  </body>
</html>
