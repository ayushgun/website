<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../../stylesheets/styles.css" />
    <style>
      pre {
        line-height: 125%;
      }
      td.linenos .normal {
        color: #6e7681;
        background-color: #0d1117;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos {
        color: #6e7681;
        background-color: #0d1117;
        padding-left: 5px;
        padding-right: 5px;
      }
      td.linenos .special {
        color: #e6edf3;
        background-color: #6e7681;
        padding-left: 5px;
        padding-right: 5px;
      }
      span.linenos.special {
        color: #e6edf3;
        background-color: #6e7681;
        padding-left: 5px;
        padding-right: 5px;
      }
      .codehilite .hll {
        background-color: #6e7681;
      }
      .codehilite {
        background: #0d1117;
        color: #e6edf3;
      }
      .codehilite .c {
        color: #8b949e;
        font-style: italic;
      } /* Comment */
      .codehilite .err {
        color: #f85149;
      } /* Error */
      .codehilite .esc {
        color: #e6edf3;
      } /* Escape */
      .codehilite .g {
        color: #e6edf3;
      } /* Generic */
      .codehilite .k {
        color: #ff7b72;
      } /* Keyword */
      .codehilite .l {
        color: #a5d6ff;
      } /* Literal */
      .codehilite .n {
        color: #e6edf3;
      } /* Name */
      .codehilite .o {
        color: #ff7b72;
        font-weight: normal;
      } /* Operator */
      .codehilite .x {
        color: #e6edf3;
      } /* Other */
      .codehilite .p {
        color: #e6edf3;
      } /* Punctuation */
      .codehilite .ch {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Hashbang */
      .codehilite .cm {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Multiline */
      .codehilite .cp {
        color: #8b949e;
        font-weight: normal;
        font-style: italic;
      } /* Comment.Preproc */
      .codehilite .cpf {
        color: #8b949e;
        font-style: italic;
      } /* Comment.PreprocFile */
      .codehilite .c1 {
        color: #8b949e;
        font-style: italic;
      } /* Comment.Single */
      .codehilite .cs {
        color: #8b949e;
        font-weight: normal;
        font-style: italic;
      } /* Comment.Special */
      .codehilite .gd {
        color: #ffa198;
        background-color: #490202;
      } /* Generic.Deleted */
      .codehilite .ge {
        color: #e6edf3;
        font-style: italic;
      } /* Generic.Emph */
      .codehilite .gr {
        color: #ffa198;
      } /* Generic.Error */
      .codehilite .gh {
        color: #79c0ff;
        font-weight: normal;
      } /* Generic.Heading */
      .codehilite .gi {
        color: #56d364;
        background-color: #0f5323;
      } /* Generic.Inserted */
      .codehilite .go {
        color: #8b949e;
      } /* Generic.Output */
      .codehilite .gp {
        color: #8b949e;
      } /* Generic.Prompt */
      .codehilite .gs {
        color: #e6edf3;
        font-weight: normal;
      } /* Generic.Strong */
      .codehilite .gu {
        color: #79c0ff;
      } /* Generic.Subheading */
      .codehilite .gt {
        color: #ff7b72;
      } /* Generic.Traceback */
      .codehilite .g-Underline {
        color: #e6edf3;
        text-decoration: underline;
      } /* Generic.Underline */
      .codehilite .kc {
        color: #79c0ff;
      } /* Keyword.Constant */
      .codehilite .kd {
        color: #ff7b72;
      } /* Keyword.Declaration */
      .codehilite .kn {
        color: #ff7b72;
      } /* Keyword.Namespace */
      .codehilite .kp {
        color: #79c0ff;
      } /* Keyword.Pseudo */
      .codehilite .kr {
        color: #ff7b72;
      } /* Keyword.Reserved */
      .codehilite .kt {
        color: #ff7b72;
      } /* Keyword.Type */
      .codehilite .ld {
        color: #79c0ff;
      } /* Literal.Date */
      .codehilite .m {
        color: #a5d6ff;
      } /* Literal.Number */
      .codehilite .s {
        color: #a5d6ff;
      } /* Literal.String */
      .codehilite .na {
        color: #e6edf3;
      } /* Name.Attribute */
      .codehilite .nb {
        color: #e6edf3;
      } /* Name.Builtin */
      .codehilite .nc {
        color: #f0883e;
        font-weight: normal;
      } /* Name.Class */
      .codehilite .no {
        color: #79c0ff;
        font-weight: normal;
      } /* Name.Constant */
      .codehilite .nd {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Decorator */
      .codehilite .ni {
        color: #ffa657;
      } /* Name.Entity */
      .codehilite .ne {
        color: #f0883e;
        font-weight: normal;
      } /* Name.Exception */
      .codehilite .nf {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Function */
      .codehilite .nl {
        color: #79c0ff;
        font-weight: normal;
      } /* Name.Label */
      .codehilite .nn {
        color: #ff7b72;
      } /* Name.Namespace */
      .codehilite .nx {
        color: #e6edf3;
      } /* Name.Other */
      .codehilite .py {
        color: #79c0ff;
      } /* Name.Property */
      .codehilite .nt {
        color: #7ee787;
      } /* Name.Tag */
      .codehilite .nv {
        color: #79c0ff;
      } /* Name.Variable */
      .codehilite .ow {
        color: #ff7b72;
        font-weight: normal;
      } /* Operator.Word */
      .codehilite .pm {
        color: #e6edf3;
      } /* Punctuation.Marker */
      .codehilite .w {
        color: #6e7681;
      } /* Text.Whitespace */
      .codehilite .mb {
        color: #a5d6ff;
      } /* Literal.Number.Bin */
      .codehilite .mf {
        color: #a5d6ff;
      } /* Literal.Number.Float */
      .codehilite .mh {
        color: #a5d6ff;
      } /* Literal.Number.Hex */
      .codehilite .mi {
        color: #a5d6ff;
      } /* Literal.Number.Integer */
      .codehilite .mo {
        color: #a5d6ff;
      } /* Literal.Number.Oct */
      .codehilite .sa {
        color: #79c0ff;
      } /* Literal.String.Affix */
      .codehilite .sb {
        color: #a5d6ff;
      } /* Literal.String.Backtick */
      .codehilite .sc {
        color: #a5d6ff;
      } /* Literal.String.Char */
      .codehilite .dl {
        color: #79c0ff;
      } /* Literal.String.Delimiter */
      .codehilite .sd {
        color: #a5d6ff;
      } /* Literal.String.Doc */
      .codehilite .s2 {
        color: #a5d6ff;
      } /* Literal.String.Double */
      .codehilite .se {
        color: #79c0ff;
      } /* Literal.String.Escape */
      .codehilite .sh {
        color: #79c0ff;
      } /* Literal.String.Heredoc */
      .codehilite .si {
        color: #a5d6ff;
      } /* Literal.String.Interpol */
      .codehilite .sx {
        color: #a5d6ff;
      } /* Literal.String.Other */
      .codehilite .sr {
        color: #79c0ff;
      } /* Literal.String.Regex */
      .codehilite .s1 {
        color: #a5d6ff;
      } /* Literal.String.Single */
      .codehilite .ss {
        color: #a5d6ff;
      } /* Literal.String.Symbol */
      .codehilite .bp {
        color: #e6edf3;
      } /* Name.Builtin.Pseudo */
      .codehilite .fm {
        color: #d2a8ff;
        font-weight: normal;
      } /* Name.Function.Magic */
      .codehilite .vc {
        color: #79c0ff;
      } /* Name.Variable.Class */
      .codehilite .vg {
        color: #79c0ff;
      } /* Name.Variable.Global */
      .codehilite .vi {
        color: #79c0ff;
      } /* Name.Variable.Instance */
      .codehilite .vm {
        color: #79c0ff;
      } /* Name.Variable.Magic */
      .codehilite .il {
        color: #a5d6ff;
      } /* Literal.Number.Integer.Long */
      .codehilite {
        background: transparent;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="content">
        <h1>Parent-Child Relationships in Multithreaded Programming</h1>
        <blockquote>
          <p>June 17, 2023</p>
        </blockquote>
        <p>
          In multithreaded programming, a process can spawn multiple threads to
          perform concurrent operations. The thread that creates (or spawns) a
          new thread is referred to as the parent thread, while the newly
          spawned thread is the child thread. It's crucial to note that these
          terms, parent and child, are primarily conceptual; in reality, all
          threads within a process share equal status and have access to the
          process's memory space. The parent-child relationship is a way to
          describe the initiation sequence of threads, not their hierarchal
          structure.
        </p>
        <p>
          For instance, in C++, we use the <code>std::thread</code> library to
          create threads. Consider the following simple code:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">child_task</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello from Child!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">child_thread</span><span class="p">(</span><span class="n">child_task</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello from Parent!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

<span class="w">    </span><span class="n">child_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          In the code above, the <code>main</code> function's thread (the
          parent) spawns <code>childThread</code> (the child) which runs
          concurrently with the parent thread.
        </p>
        <h2>Inter-thread Communication and Synchronization</h2>
        <p>
          Given that all threads within a process share the same memory space,
          they can communicate by reading and writing to shared variables.
          However, this leads to the necessity of thread synchronization to
          avoid data races and inconsistencies.
        </p>
        <p>
          The most common form of synchronization is achieved using locks or
          mutexes. Here's an example of shared data access with synchronization:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">shared_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">child_task</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">guard</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
<span class="w">    </span><span class="n">shared_var</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Child incremented shared_var to &quot;</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">shared_var</span>
<span class="w">              </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">child_thread</span><span class="p">(</span><span class="n">child_task</span><span class="p">);</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">guard</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>
<span class="w">        </span><span class="n">shared_var</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Parent incremented shared_var to &quot;</span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">shared_var</span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">child_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          In this example, both the parent and child threads increment a shared
          variable, <code>sharedVar</code>. The mutex <code>mtx</code> ensures
          that only one thread at a time can increment the variable, preventing
          data races.
        </p>
        <h2>Potential Issues in Parent-Child Thread Management</h2>
        <p>
          Without proper management, parent-child thread relationships can run
          into several issues, including deadlocks, data races, and premature
          termination of child threads if the parent finishes executing first.
        </p>
        <p>
          Consider the scenario where the parent thread doesn't wait for the
          child thread to finish its execution, as shown below:
        </p>
        <div class="codehilite">
          <pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">child_task</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Child says hello &quot;</span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span>
<span class="w">                  </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; times.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Example where parent doesn&#39;t wait</span>
<span class="w">    </span><span class="c1">// for child to finish, causing undefined</span>
<span class="w">    </span><span class="c1">// behavior</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">child_thread</span><span class="p">(</span><span class="n">child_task</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Parent says goodbye.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
        </div>

        <p>
          In the above scenario, if the parent thread finishes executing before
          the child, it might lead to the termination of the child thread before
          its completion, resulting in undefined behavior.
        </p>
        <p>
          To resolve this, C++ provides <code>join()</code> and
          <code>detach()</code> functions. The <code>join()</code> function
          makes the parent thread wait for the child thread to finish its
          execution, ensuring that the child thread's resources are safely
          reclaimed. The <code>detach()</code> function allows the child thread
          to execute independently of the parent, ensuring that the child
          thread's resources will be automatically reclaimed once it finishes
          execution.
        </p>
        <h2>Example in Action</h2>
        <p>
          In my personal experience, I recently applied parent-child thread
          relationships while working with websocket listeners; that very
          scenario, in fact, inspired me to write this post.
        </p>
        <p>
          While building a real-time research tool built on an in-house limit
          order book implementation, I needed to use two websocket listeners to
          get trade detail data and order book data from a cryptocurrency
          exchange. Each listener had two integral components, both required to
          run in parallel.
        </p>
        <p>
          Therefore, I created a parent-child relationship between the listeners
          and their respective components. The setup was achieved by
          conceptualizing each listener as a parent thread, with its two
          components as child threads. This allowed each listener to function
          independently, with their two respective components operating
          concurrently.
        </p>
        <p>
          <a
            href="https://mermaid.live/edit#pako:eNqNUstOwzAQ_JWVpRCQWiHSWw5ICYVeqHpIoRKYw6peWquNXTnOoUT5d5xHrQZRxC3ZzMzuTKZiay2IxSwIKqmkjaEK7ZZyCmMIBZpdCDXUQcAVVxuDhy0sU64AVtndO2cLI8ikWu_gWRaWFBlYbg2h4OwDxmM4R0zRImdueg-LtEMNFDyxl_-Dn006cHNCNumZ0FNP4h3_5SDQUuEXn6_sCV6tY2RWG09oXTYT3BBcJ6vMoW_8jZH7OHcZkb3of2lQ0G1KhYVUCkAlICkGZhKF-2MhCx_JE6EtDc26tIepRP9VPZmKBhFFvdBwZ6fZzr6886S5xJyfcgUP2SvMGpdopVY_4ot-iy-6FB8bsZxMjlK47lWNDmdt7ziL3WPTPM64qh0OS6uzo1qz2JqSRqxsf-lUoutjzuJP3Bd--iik2-aH1L7Ou4a3RR-xA6o3rU_E-hvZnfQI"
            ><img
              alt=""
              src="https://mermaid.ink/img/pako:eNqNUstOwzAQ_JWVpRCQWiHSWw5ICYVeqHpIoRKYw6peWquNXTnOoUT5d5xHrQZRxC3ZzMzuTKZiay2IxSwIKqmkjaEK7ZZyCmMIBZpdCDXUQcAVVxuDhy0sU64AVtndO2cLI8ikWu_gWRaWFBlYbg2h4OwDxmM4R0zRImdueg-LtEMNFDyxl_-Dn006cHNCNumZ0FNP4h3_5SDQUuEXn6_sCV6tY2RWG09oXTYT3BBcJ6vMoW_8jZH7OHcZkb3of2lQ0G1KhYVUCkAlICkGZhKF-2MhCx_JE6EtDc26tIepRP9VPZmKBhFFvdBwZ6fZzr6886S5xJyfcgUP2SvMGpdopVY_4ot-iy-6FB8bsZxMjlK47lWNDmdt7ziL3WPTPM64qh0OS6uzo1qz2JqSRqxsf-lUoutjzuJP3Bd--iik2-aH1L7Ou4a3RR-xA6o3rU_E-hvZnfQI?type=png"
          /></a>
        </p>
        <h2>Conclusion</h2>
        <p>
          Parent-child relationships can improve code organization and
          structure, while synchronization mechanisms like mutexes allow safe
          shared data access. However, improper thread management can lead to
          data races, deadlocks, or premature termination. Thus, using
          appropriate synchronization and management techniques is essential in
          C++ multithreaded programming.
        </p>
      </div>
    </div>
  </body>
</html>
